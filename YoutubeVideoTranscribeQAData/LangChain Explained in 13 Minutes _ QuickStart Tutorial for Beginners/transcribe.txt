 Langchain, what is it? Why should you use it? And how does it work? Let's have a look. Langchain is an open source framework that allows developers working with AI to combine large language models like GPT-4 with external sources of computation and data. The framework is currently offered as a Python or JavaScript package, TypeScript to be specific. In this video, we're going to start unpacking the Python framework, and we're going to see why the popularity of the framework is exploding right now, especially after the introduction of GPT-4 in March 2023. To understand what need Langchain fills, let's have a look at a practical example. So by now, we all know that Chat GPT-4 has an impressive general knowledge. We can ask it about almost anything and we'll get a pretty good answer. Suppose you want to know something specifically from your own data, your own document. It could be a book, a PDF file, a database with proprietary information. Langchain allows you to connect a large language model like GPT-4 to your own sources of data. And we're not talking about pasting a snippet of a text document into the Chat GPT prompt. We're talking about referencing an entire database filled with your own data. And not only that, once you get the information you need, you can have Langchain help you take the action you want to take. For instance, send an email with some specific information. And the way you do that is by taking the document you want your language model to reference and then you slice it up into smaller chunks and you store those chunks in a vector database. The chunks are stored as embeddings, meaning they are vector representations of the text. This allows you to build language model applications that follow a general pipeline. A user asks an initial question. This question is then sent to the language model and a vector representation of that question is used to do a similarity search in the vector database. This allows us to fetch the relevant chunks of information from the vector database and feed that to the language model as well. Now the language model has both the initial question and the relevant information from the vector database. And it's therefore capable of providing an answer or take an action. A Langchain helps build applications that follow a pipeline like this. And these applications are both data aware. We can reference our own data in a vector store. And they are agentic. They can take actions and not only provide answers to questions. And these two capabilities open up for an infinite number of practical use cases. Anything involving personal assistance will be huge. You can have a large language model book flights, transform money, pay taxes. Now imagine the implications for studying and learning new things. You can have a large language model reference and entire syllabus and help you learn the material as fast as possible. Coding, data analysis, data science, it's all going to be affected by this. One of the applications that I'm most excited about is the ability to connect large language models to existing company data such as customer data, marketing data, and so on. I think we're going to see an exponential progress in data analytics and data science or ability to connect the large language models to advanced APIs such as MetaSAPI or Google's API. It's really going to make things take off. So the main value proposition of Langchain can be divided into three main concepts. We have the LLM wrappers that allows us to connect to large language models like GPT-4 or the ones from Harkingface. Prompt templates allows us to avoid having to hard code text, which is the input to the LLMs. Then we have indexes that allows us to extract relevant information for the LLMs. The chains allows us to combine multiple components together to solve a specific task and build an entire LLM application. And finally we have the agents that allow the LLM to interact with external APIs. There's a lot to unpack in Langchain and new stuff is being added every day, but on a high level this is what the framework looks like. We have models or wrappers around models. We have prompts. We have chains. We have the embeddings and vector stores which are the indexes and then we have the agents. So what I'm going to do now is I'm going to start unpacking each of these elements by writing code. And in this video I'm going to keep it high level just to get an overview of the framework and a feel for the different elements. First thing we're going to do is we're going to pip install three libraries. We're going to need Python.n to manage the environment file with the passwords. We're going to install Langchain and we're going to install the pinecon client. Pinecon is going to be the vector store we're going to be using in this video. In the environment file we need the open AI API key. We need the pinecon environment and we need the pinecon API key. Once you have signed up for a pinecon account it's free. The API keys and the environment name is easy to find. Same thing is true for open AI. Just go to platform.obmi.com slash account slash API keys. Let's get started. So when you have the keys in an environment file all you have to do is use load.n and find that in to get the keys. And now we're ready to go. So we're going to start off with the LLMs or the wrappers around the LLMs. Then I'm going to import the open AI wrapper and I'm going to instantiate the text of nc.double or three completion model and ask it to explain what a large language model is. And this is very similar to when you call the open AI API directly. Next we're going to move over to the chat model. So gbt3.5 and gbt4 are chat models. And in order to interact with the chat model through lang chain we're going to import a schema consisting of three parts an AI message, a human message and a system message. And then we're going to import chat over AI. The system message is what you use to configure the system when you use a model and the human message is the user message. To use the chat model you combine the system message and the human message in a list and then you use that as an input to the chat model. Here I'm using gbt3.5 turbo. You could have used gbt4. I'm not using that because the open AI service is a little bit limited at the moment. So this works no problem. Let's move to the next concept which is prompt templates. So prompts are what we are going to send to our language model. But most of the time these prompts are not going to be static. They're going to be dynamic. They're going to be used in an application. And to do that lang chain has something called prompt templates. And what that allows us to do is it take a piece of text and inject a user input into that text. And we can then format the prompt with the user input and feed that to the language model. So this is the most basic example but it allows us to dynamically change the prompt with the user input. The third concept we want to look at is the concept of a chain. A chain takes a language model and a prompt template and combines them into an interface that takes an input from the user and outputs an answer from the language model. Sort of like a composite function where the inner function is the prompt template and the outer function is the language model. We can also build sequential chains where we have one chain returning an output and then a second chain taking the output from the first chain as an input. So here we have the first chain that takes a machine learning concept and gives us a brief explanation of that concept. The second chain then takes the description of the first concept and explains it to me like I'm five years old. Then we simply combine the two chains, the first chain, called chain and then the second chain called chain two into an overall chain and run that chain. And we see that the overall chain returns both the first description of the concept and the explain it to me like I'm five explanation of the concept. All right let's move on to embeddings and vector stores. But before we do that let me just change the explain it to me like I'm five prompt so that we get a few more words. We're going to go with 500 words. All right so this is our slightly longer explanation for a five-year-old. Now what I'm going to do is I'm going to take this text and I'm going to split it into chunks because we want to store it in a vector store in pine cone. And Langtian has a text bit of tool for that so I'm going to import recursive character text splitter and then I'm going to split the text into chunks like we talked about in the beginning of the video. We can extract the plain text of the individual elements of the list with page content. And what we want to do now is we want to turn this into an embedding which is just a vector representation of this text. And we can use obmeis embedding model eta. With obmeis model we can call embed query on the raw text that we just extracted from the chunks of the document and then we get the vector representation of that text or the embedding. Now we're going to check the chunks of the explanation document and we're going to store the vector representations in pine cone. So we'll import the pine cone python client and we'll import pine cone from Langtian vector stores and we initiate the pine cone client with the key and the environment that we have in the environment file. And we take the variable texts which consists of all the chunks of data we want to store. We take the embedding spot and we take an index name and we load those chunks of the embeddings to pine cone. And once we have the vector stored in pine cone we can ask questions about the data stored, what is magical about an autoencoder and then we can do a similar research in pine cone to get the answer or to extract all the relevant chunks. If we head out to pine cone we can see that the index is here, we can click on it and inspect it, check the index info, we have a total of 13 vectors in the vector store. All right so the last thing we're going to do is we're going to have a brief look at the concept of an agent. Now if you head over to OpenAI chatGPT plugins page you can see that they're showcasing a python code interpreter. Now we can actually do something similar in Langtian. So here I'm importing the create python agent as well as the python rebel tool and the python rebel from Langtian. Then we instantiate a python agent executor using an OpenAI language model and this allows us to having the language model run python code. So here I want to find the roots of a quadratic function and we see that the agent executor is using numpy root to find the roots of this quadratic function. All right so this video was meant to give you a brief introduction to the core concepts of Langtian. If you want to follow along for a deep dive into the concepts hit subscribe. Thanks for watching.